
[1207. Unique Number of Occurrences](https://leetcode.com/problems/unique-number-of-occurrences/)

Given an array of integers `arr`, return `true` _if the number of occurrences of each value in the array is **unique** or_ `false` _otherwise_.

**Example 1:**

**Input:** arr = [1,2,2,1,1,3]
**Output:** true
**Explanation:** The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.

**Example 2:**

**Input:** arr = [1,2]
**Output:** false

**Example 3:**

**Input:** arr = [-3,0,1,-3,1,1,1,-3,10,0]
**Output:** true

**Constraints:**

- `1 <= arr.length <= 1000`
- `-1000 <= arr[i] <= 1000`

so we first count the number of occurrences with a hashmap, then we could just use a set to check repeatition

```java
class Solution {

    public boolean uniqueOccurrences(int[] arr) {

        Map<Integer, Integer> m = new HashMap<Integer, Integer>();

        for (int i: arr) {

            m.put(i, m.getOrDefault(i, 0) + 1);

        }

        Set<Integer> s = new HashSet<Integer>();

        for (int i: m.values()) {

            if (!s.add(i)) {

                return false;

            }

        }

        return true;

    }

}
```

or since the question limits the range of the elements, we can just do an array

```java
class Solution {
     public boolean uniqueOccurrences(int[] arr) {
        // Step 1: Count occurrences using an array
        int[] freq = new int[2001]; // -1000 to 1000 -> shift range to 0-2000
        for (int num : arr) {
            freq[num + 1000]++;
        }

        // Step 2: Check for unique frequencies using a boolean array
        boolean[] seen = new boolean[arr.length + 1];
        for (int f : freq) {
            if (f > 0) {
                if (seen[f]) {
                    return false;
                }
                seen[f] = true;
            }
        }

        return true;
    }
}
```
