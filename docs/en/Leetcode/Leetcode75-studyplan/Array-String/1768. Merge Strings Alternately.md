

**You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.**

**Return the merged string.**

 

- Example 1:

```
Input: word1 = "abc", word2 = "pqr"
Output: "apbqcr"
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r
```

- Example 2:

```
Input: word1 = "ab", word2 = "pqrs"
Output: "apbqrs"
Explanation: Notice that as word2 is longer, "rs" is appended to the end.
word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s
```

- Example 3:
```
Input: word1 = "abcd", word2 = "pq"
Output: "apbqcd"
Explanation: Notice that as word1 is longer, "cd" is appended to the end.
word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d
```

Constraints:

- 1 <= word1.length, word2.length <= 100
- word1 and word2 consist of lowercase English letters.

## python:
### Attempt1: just iterate

```python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        if (len(word1) <= 0):
            return word2
        if (len(word2) <= 0):
            return word1
        index1 = 0 # this is the index in word1
        index2 = 0 # this is the index in word2
        length1 = len(word1) # this is the length of word1
        length2 = len(word2) # this is the length of word2
        rtrn = "" # the final return value
        while (True):
            if (index1 == length1): # no more availablle chars in word1, directly return word2
                rtrn += word2[index2:]
                return rtrn
            elif (index2 == length2): # no more availablle chars in word2, directly return word1
                rtrn += word1[index1:]
                return rtrn
            # we are certain from this place that word1 and word2 both have remaining chars
            elif (index1 == index2): # when index1 == index2, 
                rtrn += word1[index1]
                index1 += 1
            else:
                rtrn += word2[index2]
                index2 += 1

# index1 index2 rtrn
# 0      0      ""
# 1      0      "a"
# 1      1      "ap"
# 2      1      "apb"
# 2      2      "apbq"
# 3      2      "apbqc"
# 3      2      "apbqcr"
```

- Runtime 46 ms Beats 5.44%
- Memory 17.78MB Beats 27.99%

- Time Complexity: O(m+n), where m = len(word1), n = len(word2)
- Space Complexity: O(m+n)

### Optimization1: charArray

python itself does not treat a string as a charArray, as since strings are immutable in python, we cant do

```python
a = "python"
a[3] = "a"
```

so we do

```python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        if (len(word1) <= 0):
            return word2
        if (len(word2) <= 0):
            return word1
        length1 = len(word1) # this is the length of word1
        length2 = len(word2) # this is the length of word2
        if (length1 >= length2): # if word1 is longer
            # then we would expect the word1 to take 2n position
            # word2 to take 2n+1 position, and concat the rest of word1 to the tail
            rtrn = [''] * 2 * length2
            for i in range(length2):
                rtrn[2*i] = word1[i]
                rtrn[2*i+1] = word2[i]
            return ''.join(rtrn) + word1[length2:]
        else: # the opposite
            rtrn = [''] * 2 * length1
            for i in range(length1):
                rtrn[2*i] = word1[i]
                rtrn[2*i+1] = word2[i]
            return ''.join(rtrn) + word2[length1:]
```

- Runtime 32 ms Beats 84.42% 
- Memory 17.95 MB Beats 18.92%.

we could see a drastic improvement in time

- Time Complexity: O(max(n,m)), m = len(word1), n = len(word2)
- Space Complexity: O(m+n)

but actually, we can never make less than this, as no matter what we do, we need to at least iterate through the longer string, even though we can place 2 char at a time

the Space complexity, similarly, can never be better than O(m+n)

### Optimization2: merge the casesL

this is copied from one of the solutions

```python
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        new_word = []
        i = 0; j = 0
        while True:
            if i < len(word1):
                new_word.append(word1[i])
                i += 1
            if j < len(word2):
                new_word.append(word2[j])
                j += 1
            if i >= len(word1) and j >= len(word2):
                return ''.join(new_word)
```

so it is just merging some cases and cut of the uncessary ones

but actually, due to the instability of the ranking in leetcode, even this is picked from the top few in space complexity, testing gives beat 42%

I'll skip the implementations in other languages as it is just the same