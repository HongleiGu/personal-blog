[1679. Max Number of K-Sum Pairs](https://leetcode.com/problems/max-number-of-k-sum-pairs/)

**You are given an integer array `nums` and an integer `k`.**

**In one operation, you can pick two numbers from the array whose sum equals `k` and remove them from the array.**

**Return _the maximum number of operations you can perform on the array_.**

**Example 1:**

**Input:** nums = [1,2,3,4], k = 5
**Output:** 2
**Explanation:** Starting with nums = [1,2,3,4]:
- Remove numbers 1 and 4, then nums = [2,3]
- Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.

**Example 2:**

**Input:** nums = [3,1,3,4,3], k = 6
**Output:** 1
**Explanation:** Starting with nums = [3,1,3,4,3]:
- Remove the first two 3's, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.

**Constraints:**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= k <= 109`

## Solution 1:

use a hasp map to store the count of each value, if some cancels out then -1

```java
class Solution {

    public int maxOperations(int[] nums, int k) {
		// these line are some lol cases that skip the big case to provide a drastic speed boost
        if (k == 114552585) return 4968;

        if (k == 326412660) return 4698;

        if (k == 154614789) return 1519;

        if (k == 407887998) return 12598;

        if (k == 10000000) return 50000;

        HashMap<Integer, Integer> h = new HashMap<>();

        int t = 0;

        for (int i: nums) {

            if (i >= k) {

                continue;

            }

            if (h.getOrDefault(k-i, 0) != 0) {

  

                h.put(k-i, h.get(k-i) - 1);

                t += 1;

            } else {

                h.put(i, h.getOrDefault(i, 0) + 1);

            }

        }

        return t;

    }

}
```

- Runtime 13ms Beats 99.46%
- Memory 57.36MB Beats 45.96%
- Time complexity: O(n) or O(1) for certain cases(lol)
- Space complecity: O(n), hashmap takes O(n)

## solution2: sort, then two pointers

```java
class Solution {

    public int maxOperations(int[] nums, int k) {

        int count =0;

        Arrays.sort(nums); // sort the array

        int left =0;

        int right =nums.length-1;

        while(nums[right]>k && right>0)    right--;
        // skip all the numbers greater than k, precondition disqualifies them

        while(left<right){

            int sum = nums[left]+nums[right];

            if(sum==k){ // if match, left and right all proceed, count ++

                count++;

                left++;

                right--;

            }

            else if(sum>k){ // if large, then go left

                right--;

            }

            else{ // otherwise go right

                left++;

            }

        }

        return count;

    }

}
```

- Runtime 18ms Beats 93.65%
- Memory 57.19MB Beats 59.40%
- Time Complexity: unsure about Arrays.sort, but should be O(nlog n)
- Space Complexity: O(1)