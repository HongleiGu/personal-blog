---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a
### i
```haskell
palindrome :: String -> Bool
palindrome [] = True
palindrome [x] = True
palindrome (x:xs) = 
	| x == y = palindrome (init xs)
	| otherwise = False
		where y = last xs
```

last take O(n) and same as init, the code executes for O(n/2) times, so O(n^2) in total

### ii
#### A:
for example if a string has length n and the mth char and the n-m+1 char is different, then the nearest palindrome, in order to have the smallest number of changes, must pick one from the two chars to be the common one in the palindrome, if they are the same the we need no change, so all the char in the nearest palindrome must be from the original string

#### B:
similar to the above, if we have an string with as odd number of chars, say the length is 2n +1, we at most need to alter half of it, the center may remain unchanged, so n changes, and for a even length string 2n we need to alter n chars, combined, it give an edit distance of $\lfloor n/2\rfloor$ if the total length is n

#### C:
from B, the edit distance is at most $\lfloor n/2\rfloor$, if we have a nearest palindrome with length greater than $n+\lfloor n/2\rfloor$, the the edit distance contradicts with B

## b
### i:
```haskell
strings xs n = map (\x -> map (\y -> y:x) xs) (strings xs (n-1))
```

$T_{string}(n) = m*T_{string}(n-1)$

so $T_{string}(n) = m^n$

### ii:
```haskell
palindromes xs = filter palindrome (map (\x -> strings xs x) validInd)
	where
		len = length xs
		half = len `div` 2
		validInd = [len - half .. len + half]
```


### iii:
```haskell
palindist :: String -> Int
palindist xs = minOf (map (\x -> dist xs x)) (palindromes xs)
```

## c
### i:
```haskell
palindist
```

# 2
## a
### i:
0 -> 0
1 -> 1
2 -> 3 -> 5 -> 5
4 -> 6 -> 6
7 -> 3
8 -> 8
9 -> 6

## ii
applying the graphs metaphor here, a child -> parent relation is an edge and the numbers are the nodes, then we have n nodes and n edges, following graphs theory, we must have a cycle in the graph, or some ancestor of x whose parent is t, in this subgraph, we can always find a origin since there is a loop, if the node is not in the subtree, for example another subtree with elements n, then we can split it according to the subtrees and apply the same idea again, so every node has a origin

### iii
```haskell
ancestors px x :: [a] -> a -> [a]
ancestors px x = helper px x []
	where 
		helper px x tmp = case px ! x of
			x = tmp
			otherwise = helper px x (x:tmp)

origin px x = head (ancestors px x)
```

### iv:

```haskell
family ps x = filter (\x -> origin ps x == o) ps
	where o = origin ps x
```

the complexity is O(n^2) since ancestor and origin in the worst case need to iterate through every edge and is O(n), the family goes for origin n times

### v:

```haskell
adopt ps x y
	| sizeX >= sizeY = update ps y0 x0
	| otherwise = update ps x0 y0
	where
		x0 = origin ps x
		y0 = origin ps y
		familyX = family ps x
		familyY = family ps y
		sizeX = length familyX
		sizeY = length familyY 
```

## b
we define a familyList so that the family is stored as a attribute in the elements familyNodes

so (assume all element are int in the question)

```haskell
data FamilyList a = [FamilyNode a]
data FamilyNode a = Node [a] Int
```

converting FamilyList to List

```haskell
convertF :: FamilyList a -> [a]
convertF fl = map (\(Node _ a) -> a) fl
```

converting List to FamilyList

```haskell
convert :: [a] -> FamilyList
convert l = map (\a -> Node (family l a) a) l
```

modified adopt (if the function accepts FamilyNodes)

```haskell
adopt ps (Node familyX x) (Node familyY y)
	| sizeX >= sizeY = update ps y0 x0
	| otherwise = update ps x0 y0
	where
		x0 = origin ps x
		y0 = origin ps y
		sizeX = length familyX
		sizeY = length familyY 
```

the complexity is O(n) as length and origin have complexity O(n)

### iii:
so in the ps, we have some clusters that has k+1 elements in total, since every adopt forms a edge between not connected elements

say we were to apply adopt on two elements that belong to families with size m and n, then getting the origin takes m and n operations, length takes m and n operations, and update is a constant time operation, so the worst-case complexity is O(k)