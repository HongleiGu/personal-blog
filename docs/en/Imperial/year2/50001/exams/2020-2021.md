---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---

# 1
## a
### i:

Node (Node (Node (Leaf 1) (Leaf 2)) (Leaf 3)) (Leaf 4)

### ii:

```haskell
depth :: Tree a -> Int
depth (Leaf _) = 0
depth (Node (Leaf _) (Leaf _)) = 1
depth (Node a b) = max (depth a) (depth b) + 1
```

n-1

### iii:
let T_fromTree(n) denote the number of operations needs for fromTree with params of a Tree with elements n, in the worst case, we always find a left with element 1
$$\begin{aligned}
T_{fromTree}(1) &= 1\\
T_{fromTree}(n) &= T_{fromTree}(n-1) + T_{fromTree}(1) + T_{++}(n-1)\\
&= T_{fromTree(n-1)} + 1 + n-1 \\
&= T_{fromTree(n-1)} + n\\
&= O(n^2)\\
\end{aligned}$$

### iv:
depth is O(n)

```haskell
fromTree' :: Tree a -> [a]
fromTree' (Leaf x) = [x]

```

## b:
### i:
```haskell
fold' :: (a -> a -> a) -> [a] -> a
fold' f x = helper f ax
	where 
		ax = toArray x
		helper f ax@(Array n _) = [ f (ax ! i)| i <- [0..n]]
```

### ii:
```haskell
build :: [a] -> Tree a
build [x] = Leaf x
build xs = Node (build firstHalf) (build secondHalf)
	where
		(firstHalf, secondHalf) = splitAt (n `div` 2) xs
		n = length xs
```

# 2
## a
### i:
if we have winning k p, then by choosing the counterpart of the number opponent choose to match a k+1, we have winning k (p+k+1)

for any value less than k, we are certain to win by a single round

```haskell
winning :: Int -> Int -> Bool
winning k p
	| k >= p = True
	| otherwise = winning k (p - k - 1)
```

## ii:
```haskell
winning' :: Int -> Int -> Bool
winning' k p = table ! p
	where 
		table = tabulate (1,p) memo
		memo :: Int -> Bool
		memo p
			| p <= k = True
			| otherwise = table ! (p - k - 1)
```

### iii:
```haskell
moves :: Int -> Int -> [Int]

```