---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a
### i
there are three layers of loop which are about i from 0 to n-1, and j from i to n-1 and k from i to j,

O(n^2)

### ii
```haskell
mss :: Int -> Array Int Int -> Int
mss n axs = (maximum (prefixSum (take n (fromList axs)))) - (minimum (prefixSum (take n (fromList axs))))

prefixSum :: [a] -> [a]
prefixSum list = helper [sum list] (reverse list) 
	where 
		helper prefix [] = prefix
		helper prefix@(s:_) (x:xs) = helper (prefix ++ [s-x]) xs
```

reverse is O(n) helper is O(n), sum is O(n) and ++ always take one element so prefixSum is O(n)

take n is O(n), fromList can be assumed to be O(1), and take n give O(n), maximum is O(n)

so the final complexity is O(n^2)

### iii
```haskell
maxend :: Array Int Int -> Int -> Int
maxend axs n = helper listStartWithN n-1 0 0
	where
		list = fromList axs
		listStartWithN = reverse (take n list)
		helper (n: list) len curMax curSum
			| curMax > curSum + n = helper list len curMax (curSum + n)
			| otherwise = helper list len (curSum + n) (curSum + n)
		
```

### iv:

```haskell
mss :: Int -> Array Int Int -> Int
mss n axs = table ! n
	where 
		table = tabulate (0,n) memo
		memo :: Int -> Int
		memp a = 
```

## b:

```mss:

```

# 2:
## a:
### i:
```haskell
height :: Tree -> Int
height Tip = 0
height (Node n a b) = max (height a) (height b) + 1
```

## ii:
```haskell
bft :: Tree -> [Int]
bft tree = helper [tree]
	where
		helper ts = case subtrees 
			of 
				[] = values
				otherwise = values ++ (helper subtrees)
			where
				(values, subtrees) = getTreeLayer ts
		
getTreeLayer :: [Tree] -> ([Int], [Tree])
getTreeLayer ts = 
	where
		ts' = filter (\x /= Tip) ts
		subTrees = concatMap (\(Node _ a b) -> [a,b]) ts'
		values = map (\(Node a _ _) -> a) ts'
```

consider the worst case where the tree is perfect and has height h or elements n = 2^h-1

then in layer a, we have b = 2^(a-1) elements, so filter is O(b), concatMap and map each is O(b) so getTreelayer is O(b)

$T_{helper}(h) = O(b) + T_{helper}(h-1) = 2^{h-1} + T_{helper}(h-1) = 2^{h-1} + 2^{h-2} + T_{helper}(h-2)$

so $T_{helper}(h) = 2^h$-1 or $T_{helper}(h) = n$

so bfs is O(n)

### iii:
```haskell
perfect :: Tree -> Bool
perfect Tip = True
perfect (Node _ Tip Tip) = True
perfect (Node _ Tip (Node _ _ _)) = False
perfect (Node _ (Node _ _ _) Tip) = False
perfect (Node _ a b) = perfect a && perfect b


proper :: Tree -> Bool
proper tree = helper [tree]
	where
		helper [] = True
		helper ts = if checkSubTrees ts 
			then helper subtrees
			else False
			where
				subTrees = concatMap (\(Node _ a b) -> [a,b]) ts'
				


checkSubTrees :: [Tree] -> True -> Bool
checkSubTree [] a = a
checkSubTrees (Tip: xs) True = checkSubTrees xs False
checkSubTrees (Node _ _ _ : xs) True = checkSubTrees xs True
checkSubTrees (Tip: xs) False = checkSubTrees xs False
checkSubTrees (Node _ _ _ : xs) False = False
```

## b
### i
```haskell
insert :: Int -> Heap -> Heap
insert x (t, a) = (helper x t bools, a + 1)
	where
		bools = binary (x+1)
		helper x Tip _ = Node x Tip Tip
		helper x (Node _ a b, _) (True : bs) = Node a (helper x b bs)
		helper x (Node _ a b, _) (False : bs) = Node a (helper x b bs)
```

### ii:

