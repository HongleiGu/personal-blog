---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a
### i
unsure why Array (Int, Int) Int

we will just store the elements in the order of the hive
```haskell
fromHive :: [[Int]] -> Array (Int, Int) Int
fromHive hive = array index values
	where 
		concatHive = concat hive
		index = [(i,j) | i <- [(length hive - 1) .. 0] j <- [(i-1)..0]]
		values = zip index concatHive
```


## ii
```haskell
bees :: [[Int]] -> Int
bees hive = helper (fromHive hive) (0,0)
	where 
		rows = length hive - 1
		helper arrHive (row, col)
			| row == rows = 0
			| otherwise = min chooseLeft chooseRight
			where 
				chooseLeft = (arrHive ! (row + 1, col)) + (bees arrHive (row + 1, col))
				chooseRight= (arrHive ! (row + 1, col + 1)) + (bees arrHive (row + 1, col + 1))
```

assume the n is large enough to satisfy O(2^n) is greater than the complexity of the fromHive function, presumably O(n)
### iii
```haskell
bees' :: [[Int]] -> Int
bees' hive = helper (fromHive hive)
	where 
		rows = length hive - 1
		helper arrHive = table ! (0,0)
		table = tabulate ((0,0),(rows, rows)) (uncurry memo)
		memo i j = 
			| j > i = 0
			| j == rows = 0
			| otherwise = min chooseLeft chooseRight
			where
				chooseLeft (arrHive ! (i+1, j)) + (table ! (i+1, j))
				chooseRight (arrHive ! (i+1, j+1)) + (table ! (i+1, j+1))
```

## b:

assume minOf gets the minimum of a list

```haskell
bees :: [[Int]] -> Int
bees hive = helper (fromHive hive) (0,0)
	where 
		rows = length hive - 1
		helper arrHive (row, col)
			| row == rows = 0
			| otherwise = minOf ([chooseLeft,chooseRight])
			where 
				chooseLeft = (arrHive ! (row + 1, col)) + (bees arrHive (row + 1, col))
				chooseRight= (arrHive ! (row + 1, col + 1)) + (bees arrHive (row + 1, col + 1))
```

# 2:
## a:
### i:
```haskell
find :: [[a]] -> Int -> a
find xss k = concat xss !! k
```

O(n/m) n = num of elements, m = num of chunks
### ii:
since the sublist of a chunklist can always be 1
```haskell
toChunks :: [a] -> [[a]]
toChunks xs  = helper xs 1
	helper xs len
		| len > length xs = [xs]
		| otherwise = a : helper xs (len + 1)
		where 
			(a,b) = splitAt xs len
```

since in this algorithms, we have n = length xs is just above the sum of 1 to k and less than 1 to k+1, where k is the number of chunks in the result, so k < \sqrt{n}, and since splitAt is linear times

we could resonably infer the complexity is O(n\sqrt{n})
### iii:
```haskell
cons :: a -> [[a]] -> [[a]]
cons e xs = toChunks (e:(concat xs))
```

toChunks has a complexity of O(n\sqrt{n}), and cons is O(n) for generic lists, so O(n\sqrt{n})

### iv:

```haskell
find :: [[a]] -> Int -> a
find xs index =
```

## b
Deques