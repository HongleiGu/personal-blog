---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a

(denote the custom operator as cap)

also note that the pairs only include consecutive ones
### i:
```haskell
closest :: [Integer] -> (Integer, Integer)
closest [] = error "not enough elements"
closest (x:[]) = error "not enough elements"
closest (x1: x2: []) = (x1, x2)
closest (x1: x2: xs) = (x1, x2) `cap` (closest xs)
```

assume the operation cap has complexity O(1)

then in each closest recursion step, we do the operation twice or O(1)

there are n-1 steps in total so O(n1) = O(n)

### ii:
divide and conquer involves splitting the main problem in to many sub-problems and solve the main problem by solving each of the sub-problems and combine them together

### iii?
we use a function similar to qsort

```haskell
splitAt :: Int -> [Int] -> ([Int, Int])
splitAt n xs = (take n xs, drop n xs)

closest' xs = (closest' firstHalf `cap` (rl, lr) `cap` (closest' secondHalf)
	where
		(firstHalf, secondHalf) = splitAt ((length xs) `div` 2) xs
		lr = last firstHalf
		rl = head secondHalf
```

O(n\log n)

## b
### i:
```haskell
head :: AList a -> a
head (AList f _ a) = a ! f

split :: AList a -> (AList a, Alist a)
split (Alist f l xs) = (a,b)
	where
		mid = (f+l) `div` 2
		leftId = [f ... mid-1]
		rightId = [mid ... l]
		a = map (\x -> xs ! x) leftId
		b = map (\x -> xs ! x) leftId
		

last :: AList a -> a
last (AList _ l a) = a ! l
```

### iii:
```haskell
closest'' :: [Integer] -> (Integer, Integer)
closest'' axs@(Alist f l xs) =
	| l - f < 1 = error "not enough element"
	| l - f == 1 = (xs ! f, xs ! l)
	| otherwise = (closest' firstHalf `cap` (rl, lr) `cap` (closest' secondHalf)
		where 
			(firstHalf, secondHalf) = split axs
			lr = last firstHalf
			rl = head secondHalf
```

# 2
## a
### i:
```haskell
catalan' :: Int -> Integer
catalan' n = table ! n
	where
		table = tabulate (0,n) c
		c :: Int -> Integer
		c 0 = 1
		c n = sum [(table ! i) * (table ! (n-i-1)) | i <- [0..n-1]]
```

### ii:
array operations is O(1) and assume tabulate is O(n)

then c 0 take 1 step, c n needs to iterate through 0 to n-1 which takes n steps

so the final complexity is $O(\sum_{i=0}^n i  + 1) = O(n^2)$

## b
### i:
if we first calculate $A_0 * A_1$ then multiply this with $A_2$, then number of scalar operations is $(2*2*2) + (2*2*3) = 20$, but when we calculate $A_1*A_2$ first, then number of scalar operations is $(2*2*3) + (2*2*3) = 24$

### ii

```haskell
chain :: Array Int Int -> (Int, Int) -> Int
chain a (i,j) = min op1 op2
	where
		op1 = ((a ! i) * (a ! (i+1)) * (a ! (j+1))) + (chain a (i+1, j))
		op2 = (chain a (i, i+1)) + ((a ! i) * (a ! (i+12) * (a ! (j+1))) + (chain a (i+2, j))
```

### iii

```haskell
chain' :: Array Int Int -> (Int, Int) -> Int
chain' a (i,j) = table ! (i,j)
	where
		table = tabulate ((0,0),(i,j)) (uncurry c)
		c (i, i+1) = a ! (i, i+1)
		c (i,j) = min op1 op2
			where 
				op1 = ((a ! i) * (a ! (i+1)) * (a ! (j+1))) + (table ! (i+1, j))
				op2 = (table ! (i, i+1)) + ((a ! i) * (a ! (i+12) * (a ! (j+1))) + (table ! (i+2, j))
```