---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a
### (i)
The billing system is embedded in the phone call, when the getInstance change the charge() in the phoneCall must also change, resulting in a dependency or coupling

### (ii)
The duration function and the priceInPence are coupled together

### (iii)
when, for some reason, for example, we need to let the phone call be able to adapt to multiple kinds of billingSystem that may not use the singleton pattern like the current scenario, the code in charge() must change according to the billingSystem code, making the phoneCall immobile

## b
```java
package Q1;

  

import java.time.LocalTime;

  

import org.jmock.Expectations;

import org.jmock.integration.junit4.JUnitRuleMockery;

import org.junit.Rule;

import org.junit.Test;

public class PhoneCallTest {

  
  

//  Show that peak time calls are charged correctly.

//  Show that off-peak calls are charged correctly.

//  Not take any real time to run - i.e. running your unit tests should take

//  milliseconds, rather than seconds or minutes

  

  @Rule

  public JUnitRuleMockery context = new JUnitRuleMockery();

  

  private final ChargingSystem chargingSystem = context.mock(ChargingSystem.class);

  private final TimeSystem timeSystem = context.mock(TimeSystem.class);

  
  

  @Test

  public void shouldChargeCorrectlyInPeakTimes() throws Exception {

    context.checking(new Expectations(){{

      exactly(1).of(timeSystem).start();

      will(returnValue(LocalTime.of(10, 0, 0)));

      exactly(1).of(timeSystem).end();

      will(returnValue(LocalTime.of(13, 0, 0)));

      exactly(1).of(chargingSystem).addBillItem("+447770123456", "+4479341554433", 181*25);

    }});

    PhoneCall call = new PhoneCall("+447770123456", "+4479341554433", chargingSystem, timeSystem);

    call.start();

    // waitForSeconds(150);

    call.end(); // 2 pm is in peak hours

    call.charge();

  }

  

  @Test

  public void shouldChargeCorrectlyInNonPeakTimes() throws Exception {

    context.checking(new Expectations(){{

      exactly(1).of(timeSystem).start();

      will(returnValue(LocalTime.of(6, 0, 0)));

      exactly(1).of(timeSystem).end();

      will(returnValue(LocalTime.of(9, 0, 0)));

      exactly(1).of(chargingSystem).addBillItem("+447770123456", "+4479341554433", 181*10);

    }});

    PhoneCall call = new PhoneCall("+447770123456", "+4479341554433", chargingSystem, timeSystem);

    call.start();

    // waitForSeconds(150);

    call.end(); // 2 pm is in peak hours

    call.charge();

  }

}
```

```java
package Q1;

  

import java.time.LocalTime;

  

public interface TimeSystem {

  public LocalTime start();

  public LocalTime end();

}
```

```java
package Q1;

  

public interface ChargingSystem {

  public void addBillItem(String caller, String callee, long callCostInPence);

}
```

```java
package Q1;

  

import static java.time.temporal.ChronoUnit.MINUTES;

import java.time.LocalTime;

  

public class PhoneCall {

  private static final long PEAK_RATE = 25;

  private static final long OFF_PEAK_RATE = 10;

  private final String caller;

  private final String callee;

  private LocalTime startTime;

  private LocalTime endTime;

  

  private ChargingSystem chargingSystem;

  private TimeSystem timeSystem;

  public PhoneCall(String caller, String callee, ChargingSystem chargingSystem, TimeSystem timeSystem) {

    this.caller = caller;

    this.callee = callee;

    this.chargingSystem = chargingSystem;

    this.timeSystem = timeSystem;

  }

  public void start() {

    // startTime = LocalTime.now();

    startTime = timeSystem.start();

  }

  

  public void end() {

    // endTime = LocalTime.now();

    endTime = timeSystem.end();

  }

  

  public void charge() {

    chargingSystem.addBillItem(caller, callee, priceInPence());

  }

  

  private long priceInPence() {

    if (startTime.isAfter(LocalTime.of(9, 00)) && endTime.isBefore(LocalTime.of(18, 00))) {

      return duration() * PEAK_RATE;

    } else {

      return duration() * OFF_PEAK_RATE;

    }

  }

  

  private long duration() {

    return MINUTES.between(startTime, endTime) + 1;

  }

}
```

## c:
wraps the billingSystem and the time utilities in a interface so we can mock and set expectations on the interfaces' parameters when testing

## d:
```java
package Q1;

  

import static java.time.temporal.ChronoUnit.MINUTES;

import java.time.LocalTime;

  

public class PhoneCall {

  private static final long PEAK_RATE = 25;

  private static final long OFF_PEAK_RATE = 10;

  private final String caller;

  private final String callee;

  private LocalTime startTime;

  private LocalTime endTime;

  

  private ChargingSystem chargingSystem;

  private TimeSystem timeSystem;

  public PhoneCall(String caller, String callee, ChargingSystem chargingSystem, TimeSystem timeSystem) {

    this.caller = caller;

    this.callee = callee;

    this.chargingSystem = chargingSystem;

    this.timeSystem = timeSystem;

  }

  public void start() {

    // startTime = LocalTime.now();

    startTime = timeSystem.start();

  }

  

  public void end() {

    // endTime = LocalTime.now();

    endTime = timeSystem.end();

  }

  

  public void charge() {

    chargingSystem.addBillItem(caller, callee, priceInPence());

  }

  

  private long priceInPence() {

    if (

      (startTime.isAfter(LocalTime.of(9, 00)) && startTime.isBefore(LocalTime.of(18, 00)))

        ||

      (endTime.isAfter(LocalTime.of(9, 00)) && endTime.isBefore(LocalTime.of(18, 00)))

    ) {

      return duration() * PEAK_RATE;

    } else {

      return duration() * OFF_PEAK_RATE;

    }

  }

  

  private long duration() {

    return MINUTES.between(startTime, endTime) + 1;

  }

}
```

```java
package Q1;

  

import java.time.LocalTime;

  

import org.jmock.Expectations;

import org.jmock.integration.junit4.JUnitRuleMockery;

import org.junit.Rule;

import org.junit.Test;

public class PhoneCallTest {

  
  

//  Show that peak time calls are charged correctly.

//  Show that off-peak calls are charged correctly.

//  Not take any real time to run - i.e. running your unit tests should take

//  milliseconds, rather than seconds or minutes

  

  @Rule

  public JUnitRuleMockery context = new JUnitRuleMockery();

  

  private final ChargingSystem chargingSystem = context.mock(ChargingSystem.class);

  private final TimeSystem timeSystem = context.mock(TimeSystem.class);

  
  

  @Test

  public void shouldChargeCorrectlyInPeakTimes() throws Exception {

    context.checking(new Expectations(){{

      exactly(1).of(timeSystem).start();

      will(returnValue(LocalTime.of(4, 0, 0)));

      exactly(1).of(timeSystem).end();

      will(returnValue(LocalTime.of(13, 0, 0)));

      exactly(1).of(chargingSystem).addBillItem("+447770123456", "+4479341554433", (9*60+1)*25);

    }});

    PhoneCall call = new PhoneCall("+447770123456", "+4479341554433", chargingSystem, timeSystem);

    call.start();

    // waitForSeconds(150);

    call.end(); // 2 pm is in peak hours

    call.charge();

  }

  

  @Test

  public void shouldChargeCorrectlyInNonPeakTimes() throws Exception {

    context.checking(new Expectations(){{

      exactly(1).of(timeSystem).start();

      will(returnValue(LocalTime.of(6, 0, 0)));

      exactly(1).of(timeSystem).end();

      will(returnValue(LocalTime.of(8, 0, 0)));

      exactly(1).of(chargingSystem).addBillItem("+447770123456", "+4479341554433", (2*60+1)*10);

    }});

    PhoneCall call = new PhoneCall("+447770123456", "+4479341554433", chargingSystem, timeSystem);

    call.start();

    // waitForSeconds(150);

    call.end(); // 2 pm is in peak hours

    call.charge();

  }

}
```

# 2
## a
### (i)
The MVC separates the three crucial parts into individual parts of code, reducing coupling and allows more flexible design
### (ii)
The MVC Pattern also allows for more flexible testing, since the functions are separated, we can test each part separately, for example, testing business logic without invoking the view, so the tests run faster without the need of human intervention

### (iii)

the PAC pattern

## b
the question dont need us to separate View nad Controller

```java
package Q2;

  

import java.awt.Panel;

import java.awt.event.ActionEvent;

import java.awt.event.ActionListener;

import java.util.ArrayList;

import java.util.List;

  

import javax.swing.JButton;

import javax.swing.JFrame;

import javax.swing.JLabel;

import javax.swing.JTextField;

  

public class ViewAndController {

  private List<JButton> listOfButtons = new ArrayList<JButton>();

  private Model model;

  private JTextField currentMax;

  private JTextField currentMean;

  

  public ViewAndController() {

    this.model = new Model();

    JFrame frame = new JFrame("Simple Stats");

    frame.setSize(250, 350);

    Panel panel = new Panel();

    this.currentMax = new JTextField(11);

    this.currentMean = new JTextField(11);

    panel.add(new JLabel("Max: value "));

    panel.add(currentMax);

    panel.add(new JLabel("Mean: value "));

    panel.add(currentMean);

    for (int i = 1; i <= 12; i++) {

      JButton button = new JButton(String.valueOf(i));

      listOfButtons.add(button);

      panel.add(button);

    }

    addActionListener();

    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    frame.getContentPane().add(panel);

    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    frame.setVisible(true);

  }

  

  public void addActionListener() {

    for (int i = 0; i < listOfButtons.size(); i++) {

      listOfButtons.get(i).addActionListener(new Listener(i+1));

    }

  }

  

  private class Listener implements ActionListener {

  

    private int n;

  

    public Listener(int n) {

      this.n = n;

    }

  

    @Override

    public void actionPerformed(ActionEvent e) {

      model.addNumber(n);

      currentMax.setText(String.valueOf(model.getMax()));

      currentMean.setText(String.valueOf(model.getMean()));

    }

  }

}
```

```java
package Q2;

  

import java.util.ArrayList;

import java.util.List;

  

public class Model {

  private final List<Integer> numbers = new ArrayList<>();

  private int max;

  private double mean;

  

  public void addNumber(int n) {

    numbers.add(n);

    max = Math.max(max, n);

    mean = numbers.stream().mapToInt(val -> val).average().orElse(0.0);

  }

  

  public int getMax() {

    return max;

  }

  

  public double getMean() {

    return mean;

  }

}
```

```java
package Q2;

  

public class SimpleStats {

  public static void main(String[] args) {

    new ViewAndController();

  }

}
```

##