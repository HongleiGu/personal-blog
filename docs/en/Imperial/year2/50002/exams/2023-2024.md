---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a
### (i)
factory pattern

### (ii)
singleton pattern

## b

```java
package bookings;

  

import java.time.LocalDate;

import java.util.List;

  

import flights.Airport;

import flights.FlightNumber;

import flights.FrequentFlyerStatus;

import flights.Seat;

  

public abstract class Flight {

  public abstract List<Seat> seatingOptions(FrequentFlyerStatus status);

  // public abstract int calculateFare();

  

  private static int PENCE_PER_MILE;

  private static int STANDARD_FEE_PENCE;

  

  public int calculateFare() {

    return origin.distanceTo(destination) * PENCE_PER_MILE + STANDARD_FEE_PENCE;

  }

  

  private FlightNumber flightNumber;

  private LocalDate date;

  private Airport origin;

  private Airport destination;

}
```

```java
package bookings;

  

import availability.SeatManager;

import flights.*;

import java.time.LocalDate;

import java.util.Collections;

import java.util.List;

  

public class EconomyFlight extends Flight {

  

  private static final int PENCE_PER_MILE = 15;

  private static final int STANDARD_FEE_PENCE = 4000;

  

  public EconomyFlight(

      FlightNumber flightNumber, LocalDate date, Airport origin, Airport destination) {

    this.flightNumber = flightNumber;

    this.date = date;

    this.origin = origin;

    this.destination = destination;

  }

  

  private final FlightNumber flightNumber;

  private final LocalDate date;

  private final Airport origin;

  private final Airport destination;

  

  public List<Seat> seatingOptions(FrequentFlyerStatus status) {

    if (date.isBefore(LocalDate.now())) {

      throw new BookingException("Flight is in the past");

    }

    List<Seat> availableSeats = SeatManager.getInstance().getAvailableSeats(flightNumber, date);

    List<Seat> allAvailableEconomySeats =

        availableSeats.stream().filter(s -> s.cabin() == ServiceLevel.ECONOMY).toList();

    return switch (status) {

      case BASIC -> pickOneAtRandomFrom(allAvailableEconomySeats);

      case SILVER, ELITE -> allAvailableEconomySeats;

    };

  }

  

  private List<Seat> pickOneAtRandomFrom(List<Seat> allAvailableEconomySeats) {

    int randomPositionInList = (int) (Math.random() * (allAvailableEconomySeats.size() - 1));

    return Collections.singletonList(allAvailableEconomySeats.get(randomPositionInList));

  }

  

  // public int calculateFare() {

  //   return origin.distanceTo(destination) * PENCE_PER_MILE + STANDARD_FEE_PENCE;

  // }

  

  @Override

  public String toString() {

    return "Flight "

        + flightNumber

        + " ("

        + date

        + ") from "

        + origin

        + " to "

        + destination

        + " ("

        + ServiceLevel.ECONOMY

        + ")";

  }

}
```

```java
package bookings;

  

import availability.SeatManager;

import flights.*;

import java.time.LocalDate;

import java.util.List;

  

public class BusinessClassFlight extends Flight {

  

  private static final int PENCE_PER_MILE = 35;

  private static final int STANDARD_FEE_PENCE = 8000;

  

  public BusinessClassFlight(

      FlightNumber flightNumber, LocalDate date, Airport origin, Airport destination) {

    this.flightNumber = flightNumber;

    this.date = date;

    this.origin = origin;

    this.destination = destination;

  }

  

  private final FlightNumber flightNumber;

  private final LocalDate date;

  private final Airport origin;

  private final Airport destination;

  

  public List<Seat> seatingOptions(FrequentFlyerStatus status) {

    if (date.isBefore(LocalDate.now())) {

      throw new BookingException("Flight is in the past");

    }

    List<Seat> availableSeats = SeatManager.getInstance().getAvailableSeats(flightNumber, date);

    if (status == FrequentFlyerStatus.ELITE) {

      // Elite status customers can choose any seat, even in first class.

      return availableSeats;

    }

    return availableSeats.stream().filter(s -> s.cabin() == ServiceLevel.BUSINESS).toList();

  }

  

  // public int calculateFare() {

  //   return origin.distanceTo(destination) * PENCE_PER_MILE + STANDARD_FEE_PENCE;

  // }

  

  @Override

  public String toString() {

    return "Flight "

        + flightNumber

        + " ("

        + date

        + ") from "

        + origin

        + " to "

        + destination

        + " ("

        + ServiceLevel.BUSINESS

        + ")";

  }

}
```

## c:
dependency inversion

```java
package bookings;

  

import availability.SeatManager;

import flights.*;

import java.time.LocalDate;

import java.util.List;

  

public class BusinessClassFlight extends Flight {

  

  private static final int PENCE_PER_MILE = 35;

  private static final int STANDARD_FEE_PENCE = 8000;

  

  public BusinessClassFlight(

      FlightNumber flightNumber, LocalDate date, Airport origin, Airport destination) {

    this.flightNumber = flightNumber;

    this.date = date;

    this.origin = origin;

    this.destination = destination;

  }

  

  private final FlightNumber flightNumber;

  private final LocalDate date;

  private final Airport origin;

  private final Airport destination;

  

  public List<Seat> seatingOptions(FrequentFlyerStatus status, SeatControl control) {

    if (date.isBefore(LocalDate.now())) {

      throw new BookingException("Flight is in the past");

    }

    List<Seat> availableSeats = control.getAvailableSeats(flightNumber, date);

    if (status == FrequentFlyerStatus.ELITE) {

      // Elite status customers can choose any seat, even in first class.

      return availableSeats;

    }

    return availableSeats.stream().filter(s -> s.cabin() == ServiceLevel.BUSINESS).toList();

  }

  

  // public int calculateFare() {

  //   return origin.distanceTo(destination) * PENCE_PER_MILE + STANDARD_FEE_PENCE;

  // }

  

  @Override

  public String toString() {

    return "Flight "

        + flightNumber

        + " ("

        + date

        + ") from "

        + origin

        + " to "

        + destination

        + " ("

        + ServiceLevel.BUSINESS

        + ")";

  }

}
```

```java
package bookings;

  

import java.time.LocalDate;

import java.util.List;

  

import availability.SeatManager;

import flights.FlightNumber;

import flights.Seat;

  

public class SeatControl {

  private SeatManager manager;

  public SeatControl() {

    this.manager = SeatManager.getInstance();

  }

  

  public List<Seat> getAvailableSeats(FlightNumber flightNumber, LocalDate date) {

    return manager.getAvailableSeats(flightNumber, date);

  }

}
```

## d:
```java
package bookings;

  

import static org.junit.Assert.assertEquals;

  

import java.time.LocalDate;

import java.util.Date;

import java.util.List;

  

import org.jmock.Expectations;

import org.jmock.integration.junit4.JUnitRuleMockery;

import org.junit.Rule;

import org.junit.Test;

  

import flights.Airport;

import flights.FlightNumber;

import flights.FrequentFlyerStatus;

import flights.Seat;

import flights.ServiceLevel;

  

public class BusinessClassFlightTest {

  

  // this is not an interface

  SeatControl control = new SeatControl();

  

  @Test

  public void shouldThrowErrorWhenFlightIsInThePast() {

    BusinessClassFlight flight = new BusinessClassFlight(FlightNumber.of("past"), LocalDate.of(2005, 4, 1), Airport.LHR, Airport.CDG);

  

    try {

      flight.seatingOptions(FrequentFlyerStatus.ELITE, control);

    } catch (BookingException e) {

      assertEquals(e.getLocalizedMessage(), "Flight is in the past");

      return;

    }

    throw new Error("should throw an exception");

  }

  

  @Test

  public void shouldAllowElitesChooseAnySeat() {

    BusinessClassFlight flight = new BusinessClassFlight(FlightNumber.of("past"), LocalDate.of(2030, 4, 1), Airport.LHR, Airport.CDG);

  

    // List<Seat> seats =

    flight.seatingOptions(FrequentFlyerStatus.ELITE, control);

  

    // here, given that we dont know the actual seats in the server, we do nothing

  }

  

  @Test

  public void shouldOnlyAllowNormalPassengerChooseBusinessSeats() {

    BusinessClassFlight flight = new BusinessClassFlight(FlightNumber.of("past"), LocalDate.of(2030, 4, 1), Airport.LHR, Airport.CDG);

  

    List<Seat> seats = flight.seatingOptions(FrequentFlyerStatus.BASIC, control);

  

    // here, we check the seats to see whether business

  

    for (Seat s : seats) {

      assertEquals(s.cabin(), ServiceLevel.BUSINESS);

    }

  }

  

}
```

## b:
```java
package publications;

  

import java.util.List;

  

import org.jmock.Expectations;

import org.jmock.integration.junit4.JUnitRuleMockery;

import org.junit.Rule;

import org.junit.Test;

  

public class ArticleRepositoryTest {

  

  @Rule public JUnitRuleMockery context = new JUnitRuleMockery();

  

  Person alice = context.mock(Person.class, "alice");

  Person bob = context.mock(Person.class, "bob");

  Person charlie = context.mock(Person.class, "charlie");

  Summariser summariser = context.mock(Summariser.class);

  

  public final Article article = new Article("article");

  public final ArticleRepository repo = new ArticleRepository(summariser);

  
  

  // a

  @Test

  public void shouldExtractKeywordsOnPublication() {

    context.checking(new Expectations(){{

      exactly(1).of(summariser).summarise(article);

    }});

  

    repo.publish(article);

  }

  

  // b

  @Test

  public void shouldNotifySubscribersOnPublication() {

    context.checking(new Expectations(){{

      exactly(1).of(summariser).summarise(article); // in order to compile

      will(returnValue(List.of("testing", "Python")));

      exactly(1).of(alice).alert(article);

    }});

  

    repo.subscribeToTopic(alice, "testing");

    repo.publish(article);

  }

  

  @Test

  public void shouldNotNotifyNonSubscribersOnPublication() {

    context.checking(new Expectations(){{

      exactly(1).of(summariser).summarise(article); // in order to compile

      will(returnValue(List.of("testing", "Python")));

      never(alice).alert(article);

      never(bob).alert(article);

      never(charlie).alert(article);

    }});

  

    repo.publish(article);

  }

  

  @Test

  public void shouldOnlyNotifyOncePerArticleForSubscribersWithMultipleInterest() {

    context.checking(new Expectations(){{

      exactly(1).of(summariser).summarise(article); // in order to compile

      will(returnValue(List.of("testing", "Python")));

      exactly(1).of(alice).alert(article);

    }});

  

    repo.subscribeToTopic(alice, "testing");

    repo.subscribeToTopic(alice, "Python");

    repo.publish(article);

  }

  

  @Test

  public void shouldNotNotifyPeopleAfterTheyRemoveInterest() {

    context.checking(new Expectations(){{

      exactly(1).of(summariser).summarise(article); // in order to compile

      will(returnValue(List.of("testing", "Python")));

      never(alice).alert(article);

    }});

  

    repo.subscribeToTopic(alice, "testing");

    repo.unsubscribe(alice, "testing");

    repo.publish(article);

  }

}
```

```java
package publications;

  

import java.util.HashMap;

import java.util.HashSet;

import java.util.List;

import java.util.Map;

import java.util.Set;

  

public class ArticleRepository {

  

  // to implement

  

  public Summariser summariser;

  public Map<Person, Set<String>> map = new HashMap<Person, Set<String>>();

  

  public ArticleRepository(Summariser summariser) {

    this.summariser = summariser;

  }

  

  public void subscribeToTopic(Person person, String topic) {

    // TODO

    if (!map.containsKey(person)) {

      Set<String> set = new HashSet<>();

      set.add(topic);

      map.put(person, set);

    } else {

      Set<String> set = map.get(person);

      set.add(topic);

      map.put(person, set);

    }

  }

  

  public List<String> publish(Article article) {

    // extract the keywords

    List<String> keywords = summariser.summarise(article);

    for (Person p : map.keySet()) {

      if (interests(keywords, p)) {

        p.alert(article);

      }

    }

    return keywords;

  }

  

  public Boolean interests(List<String> keywords, Person p) {

    for (String i: map.get(p)) {

      for (String kw: keywords) {

        if (i.equals(kw)) {

          return true;

        }

      }

    }

    return false;

  }

  

  public void unsubscribe(Person person, String topic) {

    if (map.containsKey(person)) {

      Set<String> set = map.get(person);

      set.remove(topic);

      map.put(person, set);

    }

  }

  

}
```

```java
package publications;

  

public interface Person {

  public void alert(Article article);

}
```

```java
package publications;

  

import java.util.List;

  

// for mocking

  

public interface Summariser {

  public List<String> summarise(Article article);

}
```