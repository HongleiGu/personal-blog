---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a:
create an abstract class Order where the process and round functions are defined there (<span style="color:red">the process in order should be abstract, and the subclases override the process respectively</span>)
```java
package retail;

  

import java.math.BigDecimal;

import java.math.RoundingMode;

import java.util.Collections;

import java.util.List;

  

public class SmallOrder extends Order {

  

  private static final BigDecimal GIFT_WRAP_CHARGE = new BigDecimal(3);

  

  private final boolean giftWrap;

  

  public SmallOrder(

      List<Product> items,

      CreditCardDetails creditCardDetails,

      Address billingAddress,

      Address shippingAddress,

      Courier courier,

      boolean giftWrap) {

    this.items = Collections.unmodifiableList(items);

    this.creditCardDetails = creditCardDetails;

    this.billingAddress = billingAddress;

    this.shippingAddress = shippingAddress;

    this.courier = courier;

    this.giftWrap = giftWrap;

  }

  

  @Override

  public void process() {

  

    BigDecimal total = new BigDecimal(0);

  

    for (Product item : items) {

      total = total.add(item.unitPrice());

    }

  

    total = total.add(courier.deliveryCharge());

  

    if (giftWrap) {

      total = total.add(GIFT_WRAP_CHARGE);

    }

  

    CreditCardProcessor.getInstance().charge(round(total), creditCardDetails, billingAddress);

  

    if (giftWrap) {

      courier.send(new GiftBox(items), shippingAddress);

    } else {

      courier.send(new Parcel(items), shippingAddress);

    }

  }

}
```

```java
package retail;

  

import java.math.BigDecimal;

import java.math.RoundingMode;

import java.util.Collections;

import java.util.List;

  

public class BulkOrder extends Order{

  

  public BulkOrder(

      List<Product> items,

      CreditCardDetails creditCardDetails,

      Address billingAddress,

      Address shippingAddress,

      Courier courier,

      BigDecimal discount) {

    this.items = Collections.unmodifiableList(items);

    this.creditCardDetails = creditCardDetails;

    this.billingAddress = billingAddress;

    this.shippingAddress = shippingAddress;

    this.courier = courier;

    this.discount = discount;

  }

}
```

```java
package retail;

  

import java.math.BigDecimal;

import java.math.RoundingMode;

import java.util.Collections;

import java.util.List;

  

public abstract class Order {

  protected List<Product> items;

  protected CreditCardDetails creditCardDetails;

  protected Address billingAddress;

  protected Address shippingAddress;

  protected Courier courier;

  protected BigDecimal discount;

  

  public void process() {

  

    BigDecimal total = new BigDecimal(0);

  

    for (Product item : items) {

      total = total.add(item.unitPrice());

    }

  

    if (items.size() > 10) {

      total = total.multiply(BigDecimal.valueOf(0.8));

    } else if (items.size() > 5) {

      total = total.multiply(BigDecimal.valueOf(0.9));

    }

  

    total = total.subtract(discount);

  

    CreditCardProcessor.getInstance().charge(round(total), creditCardDetails, billingAddress);

  

    courier.send(new Parcel(items), shippingAddress);

  }

  

  protected BigDecimal round(BigDecimal amount) {

    return amount.setScale(2, RoundingMode.CEILING);

  }

}
```

## b
we should use the factory pattern

```java
package retail;

  

import java.math.BigDecimal;

import java.util.ArrayList;

import java.util.List;

  

public class OrderBuilder {

  private List<Product> items = new ArrayList<Product>();

  private CreditCardDetails creditCardDetails = null;

  private Address billingAddress = null;

  private Address shippingAddress = null;

  private Courier courier = null;

  private BigDecimal discount = null;

  

  // private static final BigDecimal GIFT_WRAP_CHARGE = new BigDecimal(3);

  

  private boolean giftWrap = false;

  

  public static OrderBuilder aOrderBuilder() {

    return new OrderBuilder();

  }

  

  public Order build() {

    if (this.items.size() > 3) {

      if (giftWrap) {

        throw new IllegalArgumentException("bulk Orders cannot eb wrapped");

      }

      if (shippingAddress == null) {

        return new SmallOrder(items, creditCardDetails, billingAddress, billingAddress, courier, giftWrap);

      }

      return new SmallOrder(items, creditCardDetails, billingAddress, shippingAddress, courier, giftWrap);

    }

    else {

      if (discount != null) {

        throw new IllegalArgumentException("small orders cannot have additional discount");

      }

      if (shippingAddress == null) {

        return new SmallOrder(items, creditCardDetails, billingAddress, billingAddress, courier, giftWrap);

      }

      return new SmallOrder(items, creditCardDetails, billingAddress, shippingAddress, courier, giftWrap);

    }

  }

  

  public OrderBuilder addItems(Product product) {

    this.items.add(product);

    return this;

  }

  

  public OrderBuilder withCreditCardDetails(CreditCardDetails details) {

    this.creditCardDetails = details;

    return this;

  }

  

  public OrderBuilder withBillingAddress(Address address) {

    this.billingAddress = address;

    return this;

  }

  

  public OrderBuilder withShippingAddress(Address address) {

    this.shippingAddress = address;

    return this;

  }

  

  public OrderBuilder withCourier(Courier courier) {

    this.courier = courier;

    return this;

  }

  

  public OrderBuilder withDiscount(BigDecimal discount) {

    this.discount = discount;

    return this;

  }

}
```

## c:
### (i):
the singleton pattern

## (ii):
since there is only one instance of the CreditCardProcessor class, there may be race conditions when multiple clients are attempting to request changes from the instance

### (iii):

# 2
## a:
```java
package tennis;

  

public class TennisModel {

  protected int playerOneScore = 0;

  protected int playerTwoScore = 0;

  protected final String[] scoreNames = {"Love", "15", "30", "40"};

  

  protected String score() {

    if (playerOneScore > 2 && playerTwoScore > 2) {

      int difference = playerOneScore - playerTwoScore;

      switch (difference) {

        case 0:

          return "Deuce";

        case 1:

          return "Advantage Player 1";

        case -1:

          return "Advantage Player 2";

        case 2:

          return "Game Player 1";

        case -2:

          return "Game Player 2";

      }

    }

  

    if (playerOneScore > 3) {

      return "Game Player 1";

    }

    if (playerTwoScore > 3) {

      return "Game Player 2";

    }

    if (playerOneScore == playerTwoScore) {

      return scoreNames[playerOneScore] + " all";

    }

    return scoreNames[playerOneScore] + " - " + scoreNames[playerTwoScore];

  }

  

  protected void playerOneWinsPoint() {

    playerOneScore++;

  }

  

  protected void playerTwoWinsPoint() {

    playerTwoScore++;

  }

  

  protected boolean gameHasEnded() {

    return score().contains("Game");

  }

}
```

```java
package tennis;

  

import javax.swing.*;

  

public class TennisScorer {

  

  private int playerOneScore = 0;

  private int playerTwoScore = 0;

  private TennisModel model = new TennisModel();

  

  private final String[] scoreNames = {"Love", "15", "30", "40"};

  

  public static void main(String[] args) {

    new TennisScorer().display();

  }

  

  private void display() {

  

    JFrame window = new JFrame("Tennis");

    window.setSize(400, 150);

  

    JButton playerOneScores = new JButton("Player One Scores");

    JButton playerTwoScores = new JButton("Player Two Scores");

  

    JTextField scoreDisplay = new JTextField(20);

    scoreDisplay.setHorizontalAlignment(JTextField.CENTER);

    scoreDisplay.setEditable(false);

  

    playerOneScores.addActionListener(

            e -> {

              model.playerOneWinsPoint();

              scoreDisplay.setText(model.score());

              if (model.gameHasEnded()) {

                playerOneScores.setEnabled(false);

                playerTwoScores.setEnabled(false);

              }

            });

  

    playerTwoScores.addActionListener(

            e -> {

              model.playerTwoWinsPoint();

              scoreDisplay.setText(model.score());

              if (model.gameHasEnded()) {

                playerOneScores.setEnabled(false);

                playerTwoScores.setEnabled(false);

              }

            });

  

    JPanel panel = new JPanel();

    panel.add(playerOneScores);

    panel.add(playerTwoScores);

    panel.add(scoreDisplay);

  

    window.add(panel);

  

    window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

    window.setVisible(true);

  

  }

  
  
  

}
```

## b:

## c:
