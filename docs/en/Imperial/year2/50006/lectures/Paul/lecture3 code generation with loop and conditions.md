---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---

# syntax
we first define a set of syntax for a simple programming language with statements and loops

```
stat -> ident ':=' exp |
		stat ';' stat |
		'for' ident 'from' exp 'to' exp 'do' stat 'od' 

exp ->  exp binop exp |
		unop exp |
		ident | 
		num 
		
binop -> '+' | '-' | '*' | '/'
unop -> '-'
```

the the AST data types can be defined as follows

```haskell
data Stat = Assign name Exp |
			Seq Stat State |
			ForLoop Name Exp Exp State

data Exp =  Binop Op Exp Exp |
			Unop Op Exp |
			Ident Name |
			Const Inst

data Op = Plus | Minus | Times | Divide | Minus

type Name = [Char]
```

# Target
we first state our requirements,

we consider a computer consisting of a main store, addressed from zero up to some limit, together with a program counter, a current instruction register, a pointer to the topmost item on the stack, and a temporary register.

the set of Instructions

```haskell
data Instruction = 
	Add | Sub | Mul | Div -- arithemetic operations
	| PushImm Int -- push items on stack
	| PushAbs Name -- push variable at given location onto stack
	| Pop Name -- remove top of stack & store it at given location
	| CompEq -- subtract top two elements of stack, and replace with 1 if the result was zero, 0 otherwise
	| JTrue Label -- remove top item from stack; if 1 jump to label
	| JFalse Label -- jump if stack top is 0
	| Define Label -- set up destination for jump
```

Define is a assembler directive, not an executable instruction

![slide8](docs/assets/Imperial/50006/lecture3-slide8.png)

# Assembly code:

## labels:
the assemblt code notes the start of each of the code with labels, 

## Representation in Haskell

for example, we have this assembly code

```assembly
PushAbs i
PushImm 1
Sub
Pop i
PushAbs i
PushImm 100
CompEq
JTrue start
```

then in haskell, we would do

```haskell
[
	Define "Start"
	PushAbs "i",
	PushImm 1,
	Sub,
	Pop "i",
	PushAbs "i",
	CompEQ,
	JTrue "start"
]
```
and additionally a Define "Start" to define a label

# code generator for a stack machine

The structure of the translator is derived directly from the AST data type: we deal with each of the alternatives using a separate rule

we begin with assignment

```haskell
transStat :: stat -> [instruction]
tranStat (Assign (Ident id) exp) = ...
tranStat (Seq s1 s2) = ...
tranStat (ForLoop id e1 e2 body) = ...
```

## Assignment:

```haskell
tranStat (Assign id exp) = transExp exp ++ [Pop id]
```

The output code is the set of instructions generated by transExp, joined to the one element list [Pop id]

`transExp exp` yields a list of instruction, which when executed, leave the value of the RHS of the assignment on the top of the stack

when the `pop id` instruction is exxecuted, it removes the value from the stack and stors it at the location specified by the name id

## Statement Sequence

```haskell
transStat (Seq s1 s2) = transStat s1 ++ transStat s2
```

## For loop:

The for statement is a bit more complicated

the basic idea is that given

```
for x := e1 to e2 do
	body
of
next statement
```

and we want to output code to be

```
	x := e1
label1:
	if x > e2 then goto label2
	body
	x := x + 1
	goto label1
label2:
	next statement
```

in assembly

```
[
	PushImm 1 # (initalisation)
	Pop "x",
	Define L1,
	PushImm 10 # (test)
	PushAbs "x"
	CompGt
	JTrue L2
	PushAbs "a" # (body)
	PushAbs "x"
	Add, Pop "a" # (store a + x in a)
	PushAbs "x" # (increment)
	PushImm 1
	Add,
	Pop "x", # (store x + 1 in x)
	Jump L1,
	Define L2
]
```

then we can write down the template

```haskell
transStat (ForLoop id e1 e2 body)
=   transExp e1 ++ [Pop id] ++
	[Define label1] ++
	transExp e2 ++ [PushAbs id] ++ [CompGt] ++
	[JTrue label2] ++
	transStat body ++
	[PushAbs id] ++ [PushImm 1] ++ [Add] ++ [Pop id] ++
	[Jump label1] ++
	[Define label2]

```

## Expressions:

this is easier

```haskell
transExp :: Exp -> [Instruction]
transExp (Binop op e1 e2)
=   transExp e1 ++
	transExp e2 ++
	transOp op
transExp (Unop op e)
=   transExp e ++
	transUnop op
transExp (Ident id) = [PushAbs id]
transExp (Const v) = [PushImm v]
transOp Plus = [Add]
transOp Minus = [Sub]
transOp Times = [Mul]
transOp Divide = [Div]
transUnop Minus = [Negate]
```

# how to do this in java

## define the AST:

Each ASTnode type StatementTree abstract class

Each node has members, constructor, and accepts a vistor

```java
public abstract class StatementTree { 
	public abstract void Accept(StatementTreeVisitor v); 
} 

public class AssignNode extends StatementTree { 
	String lhs; ExpressionTree rhs; 
	AssignNode(String _lhs, ExpressionTree _rhs) { 
		lhs = _lhs; rhs = _rhs; 
	} 
	public void Accept(StatementTreeVisitor v) { 
		v.visitAssignNode(lhs, rhs); 
	} 
}

public class CompoundNode extends StatementTree { 
	Vector body; // Vector of StatementTree 
	CompoundNode(Vector _body) { 
		body = _body; 
	} 

	public void Accept(StatementTreeVisitor v) { 
		v.visitCompoundNode(body); 
	}
} 

public class IfThenNode extends StatementTree { 
	ExpressionTree cond; StatementTree body; 
	IfThenNode(ExpressionTree _cond, StatementTree _body) { 
		cond = _cond; body = _body; 
	} 
	public void Accept(StatementTreeVisitor v) { 
		v.visitIfThenNode(cond, body); 
	}
}
```


## define the visitor class

```java
public abstract class StatementTreeVistor {
	abstract void visitCompoundNode(Vector body);
	abstract void visitAssignNode(String lhs, ExpressionTree rhs);
	abstract void visitIfThenNode(ExpressionTree cond, StatementTree body);
}

// To define a function to walk the AST, create a Vistor like this:

public class ExampleVistor extends StatementTreeVistor {
	void visitCompoundVistor (Vector body) {
		// case for Compound statement node
	}

	void visitAssignNode(String lhs, ExpressionTree rhs) {
		// case for Assign statement node
	}

	void visitIfThenNode(ExpressionTree cond, StatementTree body) {
		// case for If-Then statement node
	}
}
```

## define a Vistor that generates code

```java
...
void visitIfThenNode(ExpressionTree cond, StatementTree body) { 
	// print instructions which, when executed, will leave 
	// expression value at top of stack 
	UniqueLabel skiplabel = new UniqueLabel(); 
	cond.Accept(new TranslateExpVisitor()); 
	System.out.println("JFalse "+skiplabel.toString()); 
	body.Accept(this); 
	System.out.println("Define "+skiplabel.toString()); }
```



