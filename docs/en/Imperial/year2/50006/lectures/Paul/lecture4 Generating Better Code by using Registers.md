---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---

# intro
we want
- declarations (constants, records etc)
- storage management
- procedures and functions
# unbounded number of registers:

in the section we concentrate on using registers well in arithmetic expressions:

- Initially assume there is enough registers
- Invent a scheme to handle cases where we run out of registers
- Modify the translator to evaluate expressions in the order which minimises the number of registers needed

we still instructions for the register machine

```haskell
data Instruction = 
	  Add reg reg
	| Sub reg reg
	| Load reg name -- (reg := value at location name)
	| LoadImm reg num -- (load constant into reg)
	| Store reg name -- (store reg at location name)
	| Push reg -- (push reg onto stack)
	| Pop reg -- (remove value from stack & put it in the reg)
	| CompEq reg reg -- (subtract reg from reg & set reg to 1)
	| JTrue label -- (remove top item from stack; if 1 jump to label) 
	| JFalse label -- (jump if stack top is 0) 
	| Define label -- (set up destination for jump)
```

## the Translation function

- the translation function transExp requires an extra parameter which specifies the register in which the result to be left

```haskell
transExp :: exp -> reg -> [instruction]
```

- the code generated by `transExp e Ri` can use registers $R_i,R_{i+1}$ upwards, but must leave the other registers $(R_0,\dots,R_{i-1})$ intact
- some easy cases
```haskell
transExp (Const n) r = [LoadImm r n]
transExp (Ident x) r = [Load r x]
```

on binary:

```haskell
transExp (Binop op e1 e2) r
  = transExp e1 r ++
	transExp e2 (r + 1) ++
	transBinop op r (r+1)
where
	transBinop Plus r1 r2 = [Add r1 r2]
	transBinop Minus r1 r2 = [Sub r1 r2]
	...
```

so consider the case of 3 * x + 4

![slide12](lecture4-slide12.png)

then follow our definition

```haskell
transExp (Binop Plus 
	(Binop Times 
		(Ident "x")
		(Const 3)
	)
	(Const 4)
)
= 
[
	Load R0 "x",
	LoadImm R1 3,
	Mul R0 R1,
	LoadImm R1 4,
	Add R0 R1
]
```

improvements:

we let the mul instruction take and immediate value

so the instructions can be `MulImm R0 3`

then 

```haskell
transExp (Binop op e1 e2) r
  = transExp e1 r ++
	transBinopImm op r (r+1)
where
	transBinopImm Plus r n = [AddImm r n]
	transBinopImm Minus r n = [SubImm r n]
	...
```

to allow communtativity

```haskell
transExp (Binop op (Const n) e2) r
	| commutative op = transExp e2 r ++ transBinopImm op r n
```

but we dont have an unbounded number of registers

# The Accumulator Machine

This machine has a stack and just one register, the accumulator. THe stack is used for intermediate values as before, but arithmetic etc. instruction are always the form:

```
Acc := Acc + Store[SP]
SP := SP + 1
```

The instruction set is

```haskell
data Instruction = 
	Add | Sub | Mul | Div |
	AddImm num | ... |
	CompEq | ... |
	Push |
	Pop |
	Load Name |
	LoadImm num |
	Store name |
	Jump label |
	JTrue label |
	JFalse label |
	Define label
```

the instructions do:

- Add:`Acc := Acc + Store[SP]; SP := SP + 1`
- Push: `SP := SP + 1; Store[SP] := ACC`
- Pop: `Acc := Store[SP]; SP := SP + 1`
- Load name: `Acc := Store[name]`
- Store name: `Store[name] := Acc`

## Translator for this

```haskell
transExp (Const n) = [LoadImm n]
transExp (Ident x) = [Load x]
transExp (Binop op e1 e2)
  = transExp e2 ++ -- e2 has to be evaluated before e1 so that it forms the right-hand operand of the binary operator
	[Push] ++
	transExp e1 ++
	transBinop op
where
	transBinop Plus = [Add]
	etc.
```

# limited registers:

A neat solution to this problem of running out of registers is to combine the register machine and accumulator strategies

- while free registers remain, use the register machine strategy
- when the limit is reached (when there is one register left), revert to the accumulator strategy, with the last register as the accumulator
The effect is that most expressions get the full benefit of registers, while unusually large expressions are handled correctly

so the translator would look like this

```haskell
transExp (Const n) r = [LoadImm r n]
transExp (Ident x) r = [Load r x]
transExp (Binop op e1 e2) r
  = if r == MAXREG then -- if no more registers, use stack for e2 while evaluating e1
		transExp e2 r ++
		[Push r] ++
		transExp e1 r ++
		transBinopStack op r -- Arithmetic instruction gets one operand from stack (next slide)
	else if r < MAXREG -- if there are more registers, use register r to hold e1. Evaluate e2 leaving the result in r+1
		transExp e1 r ++
		transExp e2 (r+1) ++
		transBinop op r (r+1) -- Arithmetic instruction gets both operands from registers
```

and for transBinop

if there is enough registers, generate arithmetic instruction which takes register operands
```haskell
transBinop Plus r1 r2 = [Add r1 r2]
transBinop Minus r1 r2 = [Sub r1 r2]
	etc.
```


if there is only one register left, we need an arithemetic instruction which takes one operand from the top of the stack, as in the accumulator machine

```haskell

transBinopStack Add r = [AddStack r]
transBinopStack Sub r = [SubStack r]
```

where AddStack instruction is just

`r := r + Store[SP]; SP := SP + 1`