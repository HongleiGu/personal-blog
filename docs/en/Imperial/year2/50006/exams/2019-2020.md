---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
level: Imperial
---
---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
(As the constant-change Jamie says, not examinable, at least for 2024-2025)


[(86) COMP 50006: Compilers – Ed Discussion](https://edstem.org/us/courses/67156/discussion/6485283)

# 2.
## a.
a pre-header is used when we need to extract loop-invariant code from the loop but we could find an appropriate place to put, so we assign a preheader just in front of the header and move to code inside the pre-header instead

<span style="color:red">if a loop header has more than one predecessor then the loop-invariant code must be pulled into a pre-header to maintain control flow structure</span>

## b.
a reaching definition is killed when another line of code attempts to overwrite the reaching definition so that the definition is no longer applicable in the later code

## c.
since the question ask us not to care about the availability of registers

<span style="color:red">trans functions may take a list of available register to determine where the value is despite not needing to care about spill and weights</span>

```haskell
transExp (Num a) =
	[Mov (ImmNum a) (Reg D0)]-- assume r1 is ok
transExp (Var str) = 
	[Mov (Abs str) (Reg D0)] -- we assume there is some memory lookup mechanism before this
transExp (Plus e1 e2) =
	-- since we dont use weights
	transExp e1 ++ transExp e2 ++ [Add (Reg D0) (Reg D1)]
```

```haskell
TransExp (Num i) (r : _)  

  = [Mov (ImmNum i) (Reg r)] 

TransExp (Var s) (r : _)  

  = [Mov (Abs s) (Reg r)] 

TransExp (Plus e1 e2) (r1 : r2 : rs)  

  = transExp e1 (r1 : r2 : rs)  

  ++ transExp e2 (r2 : rs)  

  ++ [Add (Reg r2) (Reg r1)]
```
## d
```haskell
transAssign (Assign var e) rs@(r1:_) = 
	transExp e rs ++ 
	[Mov (Abs var) (Reg r1)]
```

## e.
```haskell
transFor (For var lower upper stats) 
	=   [Define begin] ++ 
		transAssign (Assign var lower) ++ 
		map stats (\s -> transStat s) ++ 
		[Add (Abs var) (ImmNum 1)] ++ 
		[Cmp (Abs var) (transExp upper)] ++
		[Blt begin] ++
		[Define end]
```

## f.

we know i and j, jusr replicate it that much times

