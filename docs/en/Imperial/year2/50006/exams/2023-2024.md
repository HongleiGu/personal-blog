---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 2
## a

```haskell
transStat (DoWhile bodystat (LessThan e1 e2))
	=   [Define start] ++
		transStat bodystat ++
		transExp allRegisters (Sub e1 e2) ++
		[Blt (head allRegisters) start]
		
```

## b
when the while loop is going to be executed at least one time, the execution will first jump to the bottom then move up, causing redundancy

## c
in a do while loop, the loop is executed at least once, all the definitions, which may kill other definitions outside the loop is valid as the overwriting is guaranteed to happen, but in a while loop, this might not be the case, we might be overwriting definitions that shouldnt be overwritten

## d

```haskell
transStat (WhileDo exp bodystat)
	=   transStat (IfThen exp (DoWhile bodystat exp))
```

## e
a brand new definition

## f
in some cases, for example, in each loop we have a induction variable renewed as i = i + 1 and another j = j + 2, with the initial value j = 2i, then j = 2i holds in every loop, we can store then in one register

|                         | `LL(k)`                                 | `LR(k)`          |
| ----------------------- | --------------------------------------- | ---------------- |
| approach?               | top-down                                | bottom-up        |
| handles left-recursion? | no                                      | prefers it       |
| good errors?            | can be good                             | reasonably weak  |
| allows for ambiguity    | up to `k` tokens                        | up to `k` tokens |
| complexity?             | `O(n)` (assumes perfect `O(1)` choices) | `O(n)`           |

### Context-Sensitivity
CFGs cannot handle context-sensitivity. PEG can by using its
lookahead capacity

```bnf
<as and bs> ::= 'a' <as and bs> 'b' | epsilon
```

```peg
AsAndBs <- 'a' AsAndBs 'b' / epsilon
```

Also works. But if you add the constraint on `c`s, you'll find that as you unwind the stack to
find `b`s, you're gently forgetting how many `a`s you had in total. Poor CFGs. With PEG though,
we can cheekily use lookahead to rollback our consumed `a`s and start again (for `n >= 1`):
```peg
// need to check that the matching as and bs are followed by a 'c' otherwise it would 
// allow "aaabccc" to parse "" for the AsAndBs part!
AsAndBsAndCs <- &(AsAndBs 'c') AsAndCs !.
AsAndBs      <- 'a' AsAndBs 'b' / epsilon
AsAndCs      <- 'a' AsAndCs 'c' / 'b'*
```

```scala
def check(e: Expr, c: Constraint)(using TypeCheckerCtx[?]): (Option[Type], TypedExpr) = e match
    case ref: Expr.Ref => check(ref, c)
    case Expr.Add(x, y) => checkNumeric(x, y, c)(TypedExpr.Add.apply)
    case Expr.Mul(x, y) => checkNumeric(x, y, c)(TypedExpr.Mul.apply)
    case Expr.Num(n) => (KnownType.Int.satisfies(c), TypedExpr.Num(n))
    case Expr.Real(n) => (KnownType.Float.satisfies(c), TypedExpr.Real(n))
    case Expr.Str(s) => (KnownType.String.satisfies(c), TypedExpr.Str(s))
def check(ref: Expr.Ref, c: Constraint)(using ctx: TypeCheckerCtx[?]): (Option[Type], TypedExpr.Ref) = ref match
    case Expr.Ref.Id(v) =>
        val ty = ctx.typeOf(v)
        (ty.satisfies(c), TypedExpr.Ref.Id(v, ty))
    case Expr.Ref.Idx(r, idx) =>
        val (_, idxTyped) = check(idx, Is(KnownType.Int))
        val (arrTy, rTyped) = check(r, IsArray)
        val elemTy = for case KnownType.Array(elemTy) <- arrTy
                         ty <- elemTy.satisfies(c)
                     yield ty
        (elemTy, TypedExpr.Ref.Idx(rTyped, idxTyped, elemTy.getOrElse(?)))
     case Expr.Ref.Field(r, field) =>
        val (recordTy, rTyped) = check(r, IsRecord)
        val fieldTy = for case rty@KnownType.Record(name) <- recordTy
                          fieldTy <- ctx.typeOf(name, field).orElse(
                            ctx.error(Error.MissingField(rty, field))
                          )
                          ty <- fieldTy.satisfies(c)
                      yield ty
        (fieldTy, TypedExpr.Ref.Field(rTyped, field, fieldTy.getOrElse(?)))
def checkNumeric(x: Expr, y: Expr, c: Constraint)
                (build: (TypedExpr, TypedExpr, Type) => TypedExpr)
                (using TypeCheckerCtx[?]): (Option[Type], TypedExpr) =
    val (lhsTy, xTyped) = check(x, IsNumeric)
    val (rhsTy, yTyped) = check(y, lhsTy.fold(IsNumeric)(Is(_)))
    val ty = mostSpecific(lhsTy, rhsTy)
    (ty.satisfies(c), build(xTyped, yTyped, ty))
def mostSpecific(ty1: Option[Type], ty2: Option[Type]): Type = (ty1, ty2) match
    case (Some(?), Some(t)) => t
    case (Some(t), _)       => t
    case (None, t)          => t.getOrElse(?)
def typeCheck(prog: List[Action], tyInfo: TypeInfo): Either[NonEmptyList[Error], List[TypedAction]] = {
    given ctx: TypeCheckerCtx[List[Error]] = TypeCheckerCtx(tyInfo, List.newBuilder)
    val typedProg = prog.map(check)
    ctx.errors match {
        case err :: errs => Left(NonEmptyList(err, errs))
        case Nil         => Right(typedProg)
    }
}
class TypeCheckerCtx[C](tyInfo: TypeInfo, errs: mutable.Builder[Error, C]) {
    def errors: C = errs.result()

    def typeOf(v: String): KnownType = tyInfo.varTys(v)
    def typeOf(name: String, field: String): Option[KnownType] = tyInfo.recordTys(name).get(field)
    def error(err: Error) =
        errs += err
        None
}
```


```scala
sealed abstract class SemType
case object ? extends SemType
enum KnownType extends SemType {
    case Int
    case Float
    case String
    case Array(ty: SemType)
    case Record(name: String)
}
```
