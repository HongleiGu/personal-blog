---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---

# 1
## a
### i
synchronisation primitives are a way of controlling access to a shared resource between multiple resources, avoiding race condition and to better allocate the resources

the synchronisation primitives include semaphores, mutex, conditional variables

### ii:
the mutex must include a lock for controlling the resource, a counter for recording if any process is in accessing the resource or is in the critical section that involves the resource, this can be either int or bool in the case of a mutex. Often, it should include the pid of the process to let OS know which process specifically is accessing the resource

## b
### i
since currently T1 is executing line 7 which locks the resource, thread 2 has to wait, T1 then do some expensive computation for 2 sec, sets buffer[next_pos] and increse the next_pos by 1, managing overflow if needed, and since next_pos is global, T2 will start form the next pos of the T1 next_pos variable and goes on and on in turns

### ii:
(we can move expensive computation outside locks if not in critical section)

assuming the expensive computation does not involve reading or writing the buffer, we can lock each element in the buffer individually and when thread 1 enters critical section, let thread 2 wait for next_pos update or simply use next_pos + 1 for T2 and increase next_pos by 2 in line 10

in this way we can execute T1 and T2 concurrently, without causing any race conditions, ideals, this could half the execution time

### iii:
in user-level threads, OS kernel is not aware of the threads. Each process manages its own threads, so if a blocking system call occurs, it stops all the threads in the process, making the T2 wait for T1 case unachievable

### iv:
a simple solution would be to make T1 and T2 in two different processes, for example, in pintos, each process only has one thread, so stopping T1 wont affect T2

# 2
## a:
we have
- $\epsilon = 0.5nsec$
- $m = 15nsec$
if $\alpha = 90\%$

then $EAT = \epsilon\alpha + (\epsilon + m)(1-\alpha) = 0.5 * 90\% + 15.5 * 10\% = 2nsec$

## b:
no, MMU is purely hardware that uses simple arithmetic operations to translation virtual address to physical address, there is no space for software improvements

## c:
the simplest way would be just a 1-level page table, since it minimises the number of times we need to lookup in the main memory to find the page

## d:
since 8192 block and 8 byte pointer, each block contains 8184 Bytes of data

100GB/8184 = 12218963.8

so 12218964

## e:
### i:
Continuous file allocation
### ii:
Block Allocation Table

### iii:

Block Allocation Table / Block Linkage


