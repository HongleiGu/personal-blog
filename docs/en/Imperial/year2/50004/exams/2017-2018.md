---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a
```C
struct semaphore {
	int counter;
	struct lock* lock;
	struct queue* queue;
}
```

it has a counter to limit how many threads can access the resource at the same time, a queue for storing waiting threads, a lock to lock up the resource when the counter gets to 0

## b
sem_init takes the pointer to the sema struct and a initial counter value which indicates the number of threads you want to allow to access the resource at the same time

sem_down downs the semaphore, decreases the counter if it is greater than 0, otherwise block the thread and put it into the waiting queue and also lock up the resource with the lock;

sem_up ups the semaphore, increasing the counter and releasing the resource or the lock, resuming a process in the queue if not empty

## c

basically

```C
int buf[BUF_SIZE];
unsigned int next_write = 0;
unsigned int next_read = 0;
struct semaphore sema;
sem_init(sema, 1);

void writer(int value) {
	sem_down(&sema);
	buf[next_write] = value;
	next_write = (next_write + 1) % BUF_SIZE;
	sem_up(&sema);
}

int reader() {
	sem_down(&sema);
	int r = buf[next_read];
	next_read = (next_read + 1) % BUF_SIZE;
	sem_up(&sema);
	return r;
}
```

## d:
swap any of the sem_down and sem_up pairs across the two functions so that a function gets an up before down, 

2

## e:

store the tid of the threads using the resource and use the syscal waitpid(0)

# 2
## a:

memory allocation and memory protection
## b:
virtual memory is the separation of user logical memory from physical memory as only part of process needs to be in memory for execution. It is the address seen by the CPU and needs to be translated by the MMU, which is hardware, and is stored in the kernel's TLB and page table.

demand paging is only bring page to memory when it is needed, if the MMU(hardware) translates the target entry in the page table in the kernel and gets a zero, we get a page fault.

## c
### (i)

so in the first cycle, since j is 0, any j * step_size is 0, so the code keeps asking for one single page and is fast since the page will be cached for later operations

but when j is 1, different j results in different pages, so each time it need to look it in the TLB and the page table to see if match, after this, if no match we look it up in the main memory, taking a significantly more time to execute

## (ii)
following the EAT formula, either it is using a page table with a huge number of levels or it is using demand paging so the difference in the avg time can be so huge


## (iii)
it should not change much

## (iv)



## (iv)