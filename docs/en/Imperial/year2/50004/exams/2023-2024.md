---
encrypt_content:
  level: Imperial
  password: Raymond#1234
  username: hg1523
level: Imperial
---
# 1
## a
the semaphore s must contain a counter that allows atomic increment and decrement, usually a single integer variable, and a lock to lock up the resource, and also a queue that kept the waiting thread

## b:
sem_init would be init the semaphore variable or structure with a initial counter value

sem_down(&s) would be receiving a signal via the semaphore, decreasing the counter, usually by 1, and if the the counter is 0, lock up the resource

sem_up does the opposite, increase the counter value and releasing the lock

## c:
since in the code, the semaphore only allows a single thread or process to enter the critical region, X must be 1

## d:
- T1 T2 executes 1-4, semaphore is created with value 1
- T1 enters the loop and sem_down, the lock is acquired and the counter is 0
- T2 is blocked and waits, during which the semaphore has counter value 0 and resource locked up
- T1 enters the critical section on line 7
- T1 ups the semaphore, and releasing the lock, the semaphore now have counter value 1 and the resources release
- T2 enters the critical section on line 7, the resource is locked semaphore has counter 1
- T2 ups the semaphore, releasing the lock
- T1 enters the critical section on line 7
- T1 ups the semaphore, and releasing the lock, the semaphore now have counter value 1 and the resources release, T1 is terminated as no more code to execute
- T2 enters the critical section on line 7, the resource is locked semaphore has counter 1
- T2 ups the semaphore, releasing the lock, T2 is terminated as no more code to execute

## e:
### 2
```C
// assume semaphore is a struct with a lock field and a int counter
void sem_down(*struct semaphore) {
	if (semaphore -> counter > 0) {
		semaphore -> counter -= 1;
	} else {
		addToQueue(semaphore -> queue, *thread_current);
		// assume addToQueue adds thread to queue
		// and a variable thread_current gets the current running thread
	}
}

void sem_up(*struct semaphore) {
	if (notEmpty(semaphore -> queue)) {
		resume(getThread(semaphore -> queue));
	} else {
		semaphore -> counter += 1;
	}
}
```

# 2
## a
### i:
16 address, 2KByte = 2048Byte = 2^11Byte page

so the page offset is 11 and page number 5 which supports 32 pages

N = 31

### ii:
the first 4KB needs to be invalid, each page is 2KB, so make the first two entries 0x0000 (empty)

### iii:
0x1111 -> page 2
0x17B9 -> page 2 
0x1F6D -> page 3
0x2A02 -> page 5
0x1800 -> page 3
0x0013 -> page 0

so there will be 3 hits when accessing 0x17B9, 0x1800, 0x13, 3 misses so 3 MMU access

#### iv:
0x4A00 -> 9
0x6C01 -> C
0x4001 -> 8
0x3803 -> 7

need to invalidate 3 and 5, all the pages

### v:
we can use a hashed page table

## b:
### i:
RAID 1, in RAID 1, data can be served by any disk as the data is mirrored across all the disks, therefore enabling a fast read

however, in RAID 5, we have need to iterate through all the disk to find the data we need
### ii:
RAID 1: writing in RAID 1 needs to write to all the disks, but writing in RAID 5 is faster since it writes to a single disk and just updates the parity information

### iii:
we should use unbuffered I/O, since we have more writes, buffered I/O may lead to concurrency problems when some write causes the buffer to overflow, although the overhead is high, this ensures data integrity

## c:
### i:
we have to modify the user-level I/O software so it corresponds to the right pointer structure and the device drives

### ii:
user-level I/O and Device Independent OS and the device drives

### iii

4 * 1024 = 4096B